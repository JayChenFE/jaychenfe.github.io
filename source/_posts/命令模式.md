---
title: 命令模式
date: 2019-05-22 22:53:03
categories: [设计模式]
tags:
top:
---

[TOC]

# 原理

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190526093521.png)

# 示例

## 菜单程序(Js实现)

### 需求:

假设我们正在编写一个用户界面程序，该用户界面上至少有数十个Button 按钮。因为项目比较复杂，所以我们决定让某个程序员负责绘制这些按钮，而另外一些程序员则负责编写点击按钮后的具体行为，这些行为都将被封装在对象里。在大型项目开发中，这是很正常的分工。对于绘制按钮的程序员来说，他完全不知道某个按钮未来将用来做什么，可能用来刷新菜单界面，也可能用来增加一些子菜单，他只知道点击这个按钮会发生某些事情

这里运用命令模式的理由：点击了按钮之后，必须向某些负责具体行为的对象发送请求，这些对象就是请求的接收者。但是目前并不知道接收者是什么对象，也不知道接收者究竟会做什么。此时我们需要借助命令对象的帮助，以便解开按钮和负责具体行为对象之间的耦合。

设计模式的主题总是把不变的事物和变化的事物分离开来，命令模式也不例外。按下按钮之后会发生一些事情是不变的，而具体会发生什么事情是可变的。通过command 对象的帮助，将来我们可以轻易地改变这种关联，因此也可以在将来再次改变按钮的行为

### 传统实现

下面进入代码编写阶段

首先在页面中完成这些按钮的“绘制”：

```js
  <html>

    <head>
        <title></title>
    </head>

    <body>

        <button id="button1">点击按钮1</button>
        <button id="button2">点击按钮2</button>
        <button id="button3">点击按钮3</button>

        <script>
            var button1 = document.getElementById('button1'),
            var button2 = document.getElementById('button2'),
            var button3 = document.getElementById('button3');
        </script>
  	 </body>

</html>
```

接下来定义setCommand 函数，setCommand 函数负责往按钮上面安装命令。可以肯定的是，点击按钮会执行某个command 命令，执行命令的动作被约定为调用command 对象的execute()方法。
虽然还不知道这些命令究竟代表什么操作，但负责绘制按钮的程序员不关心这些事情，他只需要预留好安装命令的接口，command 对象自然知道如何和正确的对象沟通：

```js
  var setCommand = function (button, command) {
                button.onclick = function () {
                    command.execute();
                }
            };
```

最后，负责编写点击按钮之后的具体行为的程序员总算交上了他们的成果，他们完成了刷新菜单界面、增加子菜单和删除子菜单这几个功能，这几个功能被分布在MenuBar 和SubMenu 这两个对象中：

```js
            var MenuBar = {
                refresh: function () {
                    console.log('刷新菜单目录');
                }
            };
            var SubMenu = {
                add: function () {
                    console.log('增加子菜单');
                },
                del: function () {
                    console.log('删除子菜单');
                }
            };
```

在让button 变得有用起来之前，我们要先把这些行为都封装在命令类中：

```js
            var RefreshMenuBarCommand = function (receiver) {
                this.receiver = receiver;
            };
            RefreshMenuBarCommand.prototype.execute = function () {
                this.receiver.refresh();
            };
            var AddSubMenuCommand = function (receiver) {
                this.receiver = receiver;
            };

            AddSubMenuCommand.prototype.execute = function () {
                this.receiver.add();
            };
            var DelSubMenuCommand = function (receiver) {
                this.receiver = receiver;
            };
            DelSubMenuCommand.prototype.execute = function () {
                console.log('删除子菜单');
            };
```

最后就是把命令接收者传入到command 对象中，并且把command 对象安装到button 上面：

```js
            var refreshMenuBarCommand = new RefreshMenuBarCommand(MenuBar);
            var addSubMenuCommand = new AddSubMenuCommand(SubMenu);
            var delSubMenuCommand = new DelSubMenuCommand(SubMenu);
            setCommand(button1, refreshMenuBarCommand);
            setCommand(button2, addSubMenuCommand);
            setCommand(button3, delSubMenuCommand);
```

### JavaScript 中的命令模式

也许我们会感到很奇怪，所谓的命令模式，看起来就是给对象的某个方法取了execute 的名字。引入command 对象和receiver 这两个无中生有的角色无非是把简单的事情复杂化了，即使不用什么模式，用下面寥寥几行代码就可以实现相同的功能：

```js
            var bindClick = function (button, func) {
                button.onclick = func;
            };
            var MenuBar = {
                refresh: function () {
                    console.log('刷新菜单界面');
                }
            };
            var SubMenu = {
                add: function () {
                    console.log('增加子菜单');
                },
                del: function () {
                    console.log('删除子菜单');
                }
            };
            
            bindClick(button1, MenuBar.refresh);
            bindClick(button2, SubMenu.add);
            bindClick(button3, SubMenu.del);
```

其实,命令模式的由来，其实是回调（callback）函数的一个面向对象的替代品。
JavaScript 作为将函数作为一等对象的语言，跟策略模式一样，命令模式也早已融入到了JavaScript 语言之中。运算块不一定要封装在command.execute 方法中，也可以封装在普通函数中。函数作为一等对象，本身就可以被四处传递。即使我们依然需要请求“接收者”，那也未必使用面向对象的方式，闭包可以完成同样的功能。

在面向对象设计中，命令模式的接收者被当成command 对象的属性保存起来，同时约定执行命令的操作调用command.execute 方法。在使用闭包的命令模式实现中，接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可。无论接收者被保存为对象的属性，还是被封闭在闭包产生的环境中，在将来执行命令的时候，接收者都能被顺利访问。用
闭包实现的命令模式如下代码所示：

```js
		var setCommand = function( button, func ){
			button.onclick = function(){
				func();
			}
		};
		var MenuBar = {
			refresh: function(){
				console.log( '刷新菜单界面' );
			}
		};
		var RefreshMenuBarCommand = function( receiver ){
			return function(){
				receiver.refresh();
			}
		};
		var refreshMenuBarCommand = RefreshMenuBarCommand( MenuBar );
		setCommand( button1, refreshMenuBarCommand );
```

如果想更明确地表达当前正在使用命令模式，或者除了执行命令之外，将来有可能还要提供撤销命令等操作。那我们最好还是把执行函数改为调用execute 方法：

```js
            var RefreshMenuBarCommand = function (receiver) {
                return {
                    execute: function () {
                        receiver.refresh();
                    }
                }
            };
            var setCommand = function (button, command) {
                button.onclick = function () {
                    command.execute();
                }
            };
            var refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar);
            setCommand(button1, refreshMenuBarCommand);
```



## 计算器(C#)实现

设计一个计算器具有以下功能

- 可以进行整数的加减乘除
- 用户可以撤销操作
- 用户可以重新执行撤销的操作

代码如下:

Command类

```C#
    /// <summary>
    /// "Command"
    /// </summary>
    public abstract class Command
    {
        public abstract void Execute();
        public abstract void UnExecute();
    }
```

Calculator类(Receiver)

```C#
    /// <summary>
    /// "Receiver"
    /// </summary>
    public class Calculator
    {
        private int _curr = 0;
        public void Operation(char @operator, int operand)
        {
            switch (@operator)
            {
                case '+': _curr += operand; break;
                case '-': _curr -= operand; break;
                case '*': _curr *= operand; break;
                case '/': _curr /= operand; break;
            }
            Console.WriteLine($"Current value = {_curr} (afterOperating: {@operator} {operand})");
        }
    }
```

CalculatorCommand类(ConcreteCommand)

```C#
    /// <summary>
    /// "ConcreteCommand"
    /// </summary>
    public class CalculatorCommand : Command
    {
        private readonly Calculator _calculator;
        private readonly char _operator;
        private readonly int _operand;

        public CalculatorCommand(Calculator calculator, char @operator, int operand)
        {
            _operator = @operator;
            _operand = operand;
            _calculator = calculator;
        }

        public override void Execute()
        {
            _calculator.Operation(_operator, _operand);
        }
        public override void UnExecute()
        {
            _calculator.Operation(Undo(_operator), _operand);
        }

        private char Undo(char @operator)
        {
            char undo;
            switch (@operator)
            {
                case '+':
                    undo = '-';
                    break;
                case '-':
                    undo = '+';
                    break;
                case '*':
                    undo = '/';
                    break;
                case '/':
                    undo = '*';
                    break;
                default:
                    undo = ' ';
                    break;
            }
            return undo;
        }
    }
```

User类(Invoker)

```C#
    /// <summary>
    /// "Invoker"
    /// </summary>
    public class User
    {
        private readonly Calculator _calculator = new Calculator();
        private readonly List<Command> _commandList = new List<Command>();
        private int _current = 0;

        public void Redo(int levels)
        {
            Console.WriteLine("\n---- Redo {0} levels ", levels);

            for (int i = 0; i < levels; i++)
            {
                if (_current >= _commandList.Count - 1)
                {
                    break;
                }
                var command = _commandList[_current++];
                command.Execute();
            }
        }

        public void Undo(int levels)
        {
            Console.WriteLine("\n---- Undo {0} levels ", levels);
            // Perform undo operations
            for (int i = 0; i < levels; i++)
            {
                if (_current <= 0)
                {
                    break;
                }
                var command = _commandList[--_current];
                command.UnExecute();
            }
        }

        public void Compute(char @operator, int operand)
        {
            // Create command operation and execute it
            Command command = new CalculatorCommand(_calculator, @operator, operand);
            command.Execute();
            // Add command to undo list
            _commandList.Add(command);
            _current++;
        }
    }
```

客户端

```C#
   class Program
    {
        static void Main(string[] args)
        {
            // Create user and let her compute
            User user = new User();
            user.Compute('+', 100);
            user.Compute('-', 50);
            user.Compute('*', 10);
            user.Compute('/', 2);
            // Undo 4 commands
            user.Undo(4); 
            // Redo 3 commands
            user.Redo(3); 
            // Wait for user
            Console.Read();
        }
    }
```

## 盒马生鲜(python实现)

>David：听说阿里开了一家实体店——盒马鲜生，特别火爆！明天就周末了，我们一起去吃大闸蟹吧！ Tony：吃货！真是味觉的哥伦布啊，哪里的餐饮新店都少不了你的影子。不过听说盒马鲜生到处是黑科技诶，而且海生是自己挑的，还满新奇的。
>
>David：那就说好了，明天 11：00，盒马鲜生，不吃不散！
>
>Tony 和 David 来到杭州上城区的一家分店。这里食客众多，物品丰富，特别是生鲜，从几十块钱的小龙虾到几百块的大青蟹，再到一千多的俄罗斯帝王蟹，应有尽有。帝王蟹是吃不起了，Tony 和 David 挑了一只 900g 的一号大青蟹。
>
>食材挑好了，接下来就是现厂加工。加工的方式有多种，清蒸、姜葱炒、香辣炒、避风塘炒等，可以任意选择，当然不同的方式价格也有所不同。因为我们选的蟹是当时活动推荐的，所以免加工费。选择一种加工方式后进行下单，下单后会给你一个呼叫器，厨师做好了会有专门的服务人员送过来，坐着等就可以了……

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190526102057.png)
盒马鲜生之所以这么火爆，一方面是因为中国从来就不缺像 David 这样的吃货，另一方面是因为里面的海生很新鲜，而且可以自己挑选。很多人都喜欢吃大闸蟹，但是你有没有注意到一个问题？从你买大闸蟹到吃上大闸蟹的整个过程，可能都没有见过厨师，而你却能享受美味的佳肴。这里有一个很重要的角色就是服务员，她帮你下订单，然后把订单传送给厨师，厨师收到订单后根据订单做餐。我们用代码来模拟一下这个过程。

```python
from abc import ABCMeta, abstractmethod

# 引入ABCMeta和abstractmethod来定义抽象类和抽象方法


class Chef():
    "厨师"

    def steamFood(self, originalMaterial):
        print(originalMaterial + "清蒸中...")
        return "清蒸" + originalMaterial

    def stirFriedFood(self, originalMaterial):
        print(originalMaterial + "爆炒中...")
        return "香辣炒" + originalMaterial


class Order(metaclass=ABCMeta):
    "订单"

    def __init__(self, name, originalMaterial):
        self._chef = Chef()
        self._name = name
        self._originalMaterial = originalMaterial

    def getDisplayName(self):
        return self._name + self._originalMaterial

    @abstractmethod
    def processingOrder(self):
        pass


class SteamedOrder(Order):
    "清蒸"

    def __init__(self, originalMaterial):
        super().__init__("清蒸", originalMaterial)

    def processingOrder(self):
        if (self._chef is not None):
            return self._chef.steamFood(self._originalMaterial)
        return ""


class SpicyOrder(Order):
    "香辣炒"

    def __init__(self, originalMaterial):
        super().__init__("香辣炒", originalMaterial)

    def processingOrder(self):
        if (self._chef is not None):
            return self._chef.stirFriedFood(self._originalMaterial)
        return ""


class Waiter:
    "服务员"

    def __init__(self, name):
        self.__name = name
        self.__order = None

    def receiveOrder(self, order):
        self.__order = order
        print("服务员" + self.__name + "：您的 " + order.getDisplayName() +
              " 订单已经收到,请耐心等待")

    def placeOrder(self):
        food = self.__order.processingOrder()
        print("服务员" + self.__name + "：您的餐 " + food + " 已经准备好，请您慢用!")

```

测试代码：

```python
def testOrder():
    waiter = Waiter("Anna")
    steamedOrder = SteamedOrder("大闸蟹")
    print("客户David：我要一份" + steamedOrder.getDisplayName())
    waiter.receiveOrder(steamedOrder)
    waiter.placeOrder()
    print()

    spicyOrder = SpicyOrder("大闸蟹")
    print("客户Tony：我要一份" + steamedOrder.getDisplayName())
    waiter.receiveOrder(spicyOrder)
    waiter.placeOrder()


testOrder()
```

测试结果

```txt
客户David：我要一份清蒸大闸蟹
服务员Anna：您的 清蒸大闸蟹 订单已经收到,请耐心等待
大闸蟹清蒸中...
服务员Anna：您的餐 清蒸大闸蟹 已经准备好，请您慢用!

客户Tony：我要一份清蒸大闸蟹
服务员Anna：您的 香辣炒大闸蟹 订单已经收到,请耐心等待
大闸蟹爆炒中...
服务员Anna：您的餐 香辣炒大闸蟹 已经准备好，请您慢用!
```

