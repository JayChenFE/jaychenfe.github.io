---
title: 装饰者模式
date: 2019-05-04 13:31:07
categories: [设计模式]
tags:
top:
---
# 原理

**装饰模式**（Decorator Pattern）：动态地给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰模式比生成子类实现更为灵活。

## 结构图
![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190504133206.png)

# 示例

## 穿衣服(python实现)

给自己搭配了一套着装：一条卡其色休闲裤、一双深色休闲皮鞋、一条银色针扣头的黑色腰带、一件紫红色针织毛衣、一件白色衬衫、一副方形黑框眼镜。但类似的着装也可以穿在其他的人身上，比如一个老师也可以这样穿：一双深色休闲皮鞋、一件白色衬衫、一副方形黑框眼镜。

我们就用程序来模拟这样一个情景。

```python
class Person:
    "人"

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    def wear(self):
        print("我的着装是：")


class Engineer(Person):
    "工程师"

    def __init__(self, name, skill):
        super().__init__(name)
        self.__skill = skill

    def getSkill(self):
        return self.__skill

    def wear(self):
        print("我是" + self.getSkill() + "工程师" + self.getName())
        super().wear()

class Teacher(Person):
    "教师"

    def __init__(self, name, title):
        super().__init__(name)
        self.__title = title

    def getTitle(self):
        return self.__title

    def wear(self):
        print("我是" + self.getName() + self.getTitle())
        super().wear()

class ClothingDecorator(Person):
    "服装装饰器"

    def __init__(self, person):
        self._decorated = person

    def wear(self):
        self._decorated.wear()


class CasualPantDecorator(ClothingDecorator):
    "休闲裤"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一条卡其色休闲裤")


class BeltDecorator(ClothingDecorator):
    "腰带"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一条银色针扣头的黑色腰带")

class LeatherShoesDecorator(ClothingDecorator):
    "皮鞋"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一双深色休闲皮鞋")

class KnittedSweaterDecorator(ClothingDecorator):
    "针织毛衣"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一件紫红色针织毛衣")


class WhiteShirtDecorator(ClothingDecorator):
    "白色衬衫"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一件白色衬衫")


class GlassesDecorator(ClothingDecorator):
    "眼镜"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一副方形黑框眼镜")
```
客户端:
```python
def testDecorator():
    tony = Engineer("Tony", "客户端")
    pant = CasualPantDecorator(tony)
    belt = BeltDecorator(pant)
    shoes = LeatherShoesDecorator(belt)
    shirt = WhiteShirtDecorator(shoes)
    sweater = KnittedSweaterDecorator(shirt)
    glasses = GlassesDecorator(sweater)
    glasses.wear()

    print()
    decorateTeacher = GlassesDecorator(WhiteShirtDecorator(LeatherShoesDecorator(Teacher("wells", "教授"))))
    decorateTeacher.wear()
```

`decorateTeacher = GlassesDecorator(WhiteShirtDecorator(LeatherShoesDecorator(Teacher("wells", "教授"))))`这个写法，大家不要觉得奇怪，它其实就是将多个对象的创建过程合在了一起，其实是一种优雅的写法（是不是少了好几行代码？）。创建的 Teacher 对象又通过参数传给 `LeatherShoesDecorator `的构造函数，而创建的 `LeatherShoesDecorator` 对象又通过参数传给` WhiteShirtDecorator `的构造函数，以此类推……

输出结果：

```shell
我是客户端工程师Tony
我的着装是：
一条卡其色休闲裤
一条银色针扣头的黑色腰带
一双深色休闲皮鞋
一件白色衬衫
一件紫红色针织毛衣
一副方形黑框眼镜

我是wells教授
我的着装是：
一双深色休闲皮鞋
一件白色衬衫
一副方形黑框眼镜
```



### 装饰关系VS继承关系

装饰关系:

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505220317.png)

继承关系:

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505220514.png)

### 装饰模式的特点

- **可灵活地给一个对象增加职责或拓展功能**

  如上面的示例中，可任意地穿上自己想穿的衣服。不管穿上什么衣服，你还是那个你，但穿上不同的衣服你就会有不同的外表。

- **可增加任意多个装饰**

  你可以只穿一件衣服，也可以只穿一条裤子，也可以衣服和裤子各种搭配的穿，全随你意！

- **装饰的顺序不同，可能产生不同的效果**

  在上面的示例中，Tony 是针织毛衣穿在外面，白色衬衫穿在里面。当然，如果你愿意（或因为怕冷），也可以针织毛衣穿在里面，白色衬衫穿在外面。但两种着装穿出来的效果，给人的感觉肯定是完全不一样的，自己脑补一下，哈哈！

使用装饰模式的方式，想要改变装饰的顺序，也是非常简单的。只要把测试代码稍微改动一下即可，如下：

```python
def testDecorator2():
    tony = Engineer("Tony", "客户端")
    pant = CasualPantDecorator(tony)
    belt = BeltDecorator(pant)
    shoes = LeatherShoesDecorator(belt)
    sweater = KnittedSweaterDecorator(shoes)
    shirt = WhiteShirtDecorator(sweater)
    glasses = GlassesDecorator(shirt)
    glasses.wear()
```

结果如下：

```shell
我是客户端工程师Tony
我的着装是：
一条卡其色休闲裤
一条银色针扣头的黑色腰带
一双深色休闲皮鞋
一件紫红色针织毛衣
一件白色衬衫
一副方形黑框眼镜
```

### 模型抽象

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505222545.png)

上图中的 Component 是一个抽象类，代表具有某中功能（function）的组件，ComponentImplA 和 ComponentImplB 分别是其具体的实现子类。Decorator 是 Component 装饰器，里面有一个 Component 的对象 decorated，这就是被装饰的对象，装饰器可为被装饰对象添加额外的功能或行为（addBehavior）。DecoratorImplA 和 DecoratorImplB 分别是两个具体的装饰器（实现子类）。

这样一种模式很好地将装饰器与被装饰的对象进行解耦。

## Js中的装饰模式(Js实现)

### 用 AOP 装饰函数

```js
// 用 AOP 装饰函数
Function.prototype.before = function (beforefn) {
    var __self = this; // 保存原函数的引用
    return function () { // 返回包含了原函数和新函数的"代理"函数
        beforefn.apply(this, arguments); // 执行新函数，且保证this 不被劫持，新函数接受的参数
        // 也会被原封不动地传入原函数，新函数在原函数之前执行
        return __self.apply(this, arguments); // 执行原函数并返回原函数的执行结果，
        // 并且保证this 不被劫持
    }
};

Function.prototype.after = function (afterfn) {
    var __self = this;
    return function () {
        var ret = __self.apply(this, arguments);
        afterfn.apply(this, arguments);
        return ret;
    }
};
```

#### 给 window 绑定 onload 事件

##### 不使用AOP

```js
window.onload = function(){ 
 alert (1); 
} 
var _onload = window.onload || function(){}; 
window.onload = function(){ 
 _onload(); 
 alert (2); 
} 
```

##### 使用AOP

```js
window.onload = function(){ 
  alert (1); 
} 
window.onload = ( window.onload || function(){} ).after(function(){ 
  alert (2); 
}).after(function(){ 
  alert (3); 
}).after(function(){ 
  alert (4); 
}); 
```

##### 不污染原型

```js
var before = function( fn, beforefn ){ 
  return function(){ 
  beforefn.apply( this, arguments ); 
  return fn.apply( this, arguments );  } 
} 
var a = before( 
  function(){alert (3)}, 
  function(){alert (2)} 
); 
a = before( a, function(){alert (1);} ); 
a(); 
```

### AOP 的应用实例

#### 数据统计上报

页面中有一个登录 button，点击这个 button 会弹出登录浮层，与此同时要进行数据上报，
来统计有多少用户点击了这个登录 button：

##### 不使用AOP

```js
<html>
<button tag="login" id="button">点击打开登录浮层</button>
<script>
	var showLogin = function(){
		console.log( '打开登录浮层' );
		log( this.getAttribute( 'tag' ) );
	}
	var log = function( tag ){
		console.log( '上报标签为: ' + tag );
// (new Image).src = 'http:// xxx.com/report?tag=' + tag; // 真正的上报代码略
}
document.getElementById( 'button' ).onclick = showLogin;
</script>
</html>
```

在 showLogin 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面
的功能，在此处却被耦合在一个函数里

##### 使用AOP

# 优缺点

**装饰模式的优点：**

- 使用装饰模式来实现扩展比继承更加灵活，它可以在不需要创造更多子类的情况下，将对象的功能加以扩展。

- 可以动态地给一个对象附加更多的功能。

- 可以用不同的装饰器进行多重装饰，装饰的顺序不同，可能产生不同的效果。

- 装饰类和被装饰类可以独立发展，不会相互耦合；装饰模式相当于是继承的一个替代模式。

**装饰模式的缺点：**

- 与继承相比，用装饰的方式拓展功能更加容易出错，排错也更困难。对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

# 应用场景

- 有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。

- 需要动态地增加或撤销功能时。

- 不能采用生成子类的方法进行扩充时，如类定义不能用于生成子类。