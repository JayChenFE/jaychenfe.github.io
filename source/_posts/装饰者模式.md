---
title: 装饰者模式
date: 2019-05-04 13:31:07
categories: [设计模式]
tags:
top:
---
# 原理

**装饰模式**（Decorator Pattern）：动态地给一个对象增加一些额外的职责（Responsibility），就增加对象功能来说，装饰模式比生成子类实现更为灵活。

## 结构图
![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190504133206.png)

# 示例

## 穿衣服(python实现)

给自己搭配了一套着装：一条卡其色休闲裤、一双深色休闲皮鞋、一条银色针扣头的黑色腰带、一件紫红色针织毛衣、一件白色衬衫、一副方形黑框眼镜。但类似的着装也可以穿在其他的人身上，比如一个老师也可以这样穿：一双深色休闲皮鞋、一件白色衬衫、一副方形黑框眼镜。

我们就用程序来模拟这样一个情景。

```python
class Person:
    "人"

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    def wear(self):
        print("我的着装是：")


class Engineer(Person):
    "工程师"

    def __init__(self, name, skill):
        super().__init__(name)
        self.__skill = skill

    def getSkill(self):
        return self.__skill

    def wear(self):
        print("我是" + self.getSkill() + "工程师" + self.getName())
        super().wear()

class Teacher(Person):
    "教师"

    def __init__(self, name, title):
        super().__init__(name)
        self.__title = title

    def getTitle(self):
        return self.__title

    def wear(self):
        print("我是" + self.getName() + self.getTitle())
        super().wear()

class ClothingDecorator(Person):
    "服装装饰器"

    def __init__(self, person):
        self._decorated = person

    def wear(self):
        self._decorated.wear()


class CasualPantDecorator(ClothingDecorator):
    "休闲裤"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一条卡其色休闲裤")


class BeltDecorator(ClothingDecorator):
    "腰带"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一条银色针扣头的黑色腰带")

class LeatherShoesDecorator(ClothingDecorator):
    "皮鞋"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一双深色休闲皮鞋")

class KnittedSweaterDecorator(ClothingDecorator):
    "针织毛衣"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一件紫红色针织毛衣")


class WhiteShirtDecorator(ClothingDecorator):
    "白色衬衫"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一件白色衬衫")


class GlassesDecorator(ClothingDecorator):
    "眼镜"

    def __init__(self, person):
        super().__init__(person)

    def wear(self):
        super().wear()
        print("一副方形黑框眼镜")
```
客户端:
```python
def testDecorator():
    tony = Engineer("Tony", "客户端")
    pant = CasualPantDecorator(tony)
    belt = BeltDecorator(pant)
    shoes = LeatherShoesDecorator(belt)
    shirt = WhiteShirtDecorator(shoes)
    sweater = KnittedSweaterDecorator(shirt)
    glasses = GlassesDecorator(sweater)
    glasses.wear()

    print()
    decorateTeacher = GlassesDecorator(WhiteShirtDecorator(LeatherShoesDecorator(Teacher("wells", "教授"))))
    decorateTeacher.wear()
```

`decorateTeacher = GlassesDecorator(WhiteShirtDecorator(LeatherShoesDecorator(Teacher("wells", "教授"))))`这个写法，大家不要觉得奇怪，它其实就是将多个对象的创建过程合在了一起，其实是一种优雅的写法（是不是少了好几行代码？）。创建的 Teacher 对象又通过参数传给 `LeatherShoesDecorator `的构造函数，而创建的 `LeatherShoesDecorator` 对象又通过参数传给` WhiteShirtDecorator `的构造函数，以此类推……

输出结果：

```shell
我是客户端工程师Tony
我的着装是：
一条卡其色休闲裤
一条银色针扣头的黑色腰带
一双深色休闲皮鞋
一件白色衬衫
一件紫红色针织毛衣
一副方形黑框眼镜

我是wells教授
我的着装是：
一双深色休闲皮鞋
一件白色衬衫
一副方形黑框眼镜
```



### 装饰关系VS继承关系

装饰关系:

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505220317.png)

继承关系:

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505220514.png)

### 装饰模式的特点

- **可灵活地给一个对象增加职责或拓展功能**

  如上面的示例中，可任意地穿上自己想穿的衣服。不管穿上什么衣服，你还是那个你，但穿上不同的衣服你就会有不同的外表。

- **可增加任意多个装饰**

  你可以只穿一件衣服，也可以只穿一条裤子，也可以衣服和裤子各种搭配的穿，全随你意！

- **装饰的顺序不同，可能产生不同的效果**

  在上面的示例中，Tony 是针织毛衣穿在外面，白色衬衫穿在里面。当然，如果你愿意（或因为怕冷），也可以针织毛衣穿在里面，白色衬衫穿在外面。但两种着装穿出来的效果，给人的感觉肯定是完全不一样的，自己脑补一下，哈哈！

使用装饰模式的方式，想要改变装饰的顺序，也是非常简单的。只要把测试代码稍微改动一下即可，如下：

```python
def testDecorator2():
    tony = Engineer("Tony", "客户端")
    pant = CasualPantDecorator(tony)
    belt = BeltDecorator(pant)
    shoes = LeatherShoesDecorator(belt)
    sweater = KnittedSweaterDecorator(shoes)
    shirt = WhiteShirtDecorator(sweater)
    glasses = GlassesDecorator(shirt)
    glasses.wear()
```

结果如下：

```shell
我是客户端工程师Tony
我的着装是：
一条卡其色休闲裤
一条银色针扣头的黑色腰带
一双深色休闲皮鞋
一件紫红色针织毛衣
一件白色衬衫
一副方形黑框眼镜
```

### 模型抽象

![](https://raw.githubusercontent.com/JayChenFE/pic/master/20190505222545.png)

上图中的 Component 是一个抽象类，代表具有某中功能（function）的组件，ComponentImplA 和 ComponentImplB 分别是其具体的实现子类。Decorator 是 Component 装饰器，里面有一个 Component 的对象 decorated，这就是被装饰的对象，装饰器可为被装饰对象添加额外的功能或行为（addBehavior）。DecoratorImplA 和 DecoratorImplB 分别是两个具体的装饰器（实现子类）。

这样一种模式很好地将装饰器与被装饰的对象进行解耦。

# 优缺点

**装饰模式的优点：**

- 使用装饰模式来实现扩展比继承更加灵活，它可以在不需要创造更多子类的情况下，将对象的功能加以扩展。

- 可以动态地给一个对象附加更多的功能。

- 可以用不同的装饰器进行多重装饰，装饰的顺序不同，可能产生不同的效果。

- 装饰类和被装饰类可以独立发展，不会相互耦合；装饰模式相当于是继承的一个替代模式。

**装饰模式的缺点：**

- 与继承相比，用装饰的方式拓展功能更加容易出错，排错也更困难。对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

# 应用场景

- 有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。

- 需要动态地增加或撤销功能时。

- 不能采用生成子类的方法进行扩充时，如类定义不能用于生成子类。